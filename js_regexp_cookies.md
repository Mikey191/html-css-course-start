# Проверка достоверности форм. Использование Cookie.

## 1. Организация проверки форм

На предыдущем уроке мы научились создавать HTML-формы и управлять их элементами: добавлять поля, клонировать, удалять и изменять их программно. Следующим шагом в работе с формами является проверка достоверности введённых данных — то есть проверка того, что пользователь ввёл данные правильно и в нужном формате.

### Почему проверка необходима?

HTML-форма — это механизм, позволяющий собрать данные от пользователя и автоматически отправить их на сервер. Однако есть несколько важных особенностей:

- **Пользователь вводит данные вручную**. В поле «Имя» можно ввести что угодно: текст, цифры, даже спецсимволы. Браузер не проверяет содержимое поля.
- **Поля формы можно оставить пустыми**. Без проверки даже пустая форма будет отправлена на сервер.
- **Форма отправляется автоматически**, как только пользователь нажмёт кнопку отправки (`<button type="submit">`) или клавишу Enter в любом текстовом поле.

**Такая "по умолчанию" логика работы форм может привести к неправильным или неполным данным на сервере**. Поэтому необходимо внедрить механизмы **валидации** — проверки формы перед её отправкой.

### Что такое «проверка достоверности»?

Проверка достоверности формы (`form validation`) — это процесс проверки введённых пользователем данных перед отправкой на сервер. Проверяются:

- **обязательность заполнения поля**;
- **формат данных** (например, адрес электронной почты, номер телефона);
- **диапазоны чисел**;
- **минимальная/максимальная длина строки** и т. п.

#### Проверка делится на три уровня:

- **Проверка с помощью HTML-атрибутов**;
- **Проверка средствами JavaScript на клиенте**;
- **Проверка на сервере** (рассматривается отдельно при изучении `back-end`).

### Этап 1: Встроенные HTML-атрибуты

С появлением стандарта HTML5 формы получили **новые встроенные механизмы валидации**. Они позволяют **проверять данные без единой строчки JavaScript**.

**Основные атрибуты**:

- `required` — обязательное поле;
- `type="email"` — проверка, что введена почта;
- `type="number"` — только цифры;
- `min, max, step` — диапазоны значений;
- `pattern` — регулярное выражение.

#### Пример:

```html
<input type="text" placeholder="Your first name" name="name" required />
```

- Если поле с `required` оставить пустым, браузер не отправит форму и выведет сообщение: **«Заполните это поле»**.

> ⚠️ Важно: **браузер проверяет только пустоту**. Даже один пробел будет считаться введённым значением. Проверки на формат (например, только буквы) здесь не будет — для этого нужен JS или атрибут `pattern`.

### Этап 2: JavaScript-проверка перед отправкой

#### **Способ 1: Обработка события onsubmit через HTML**

При нажатии кнопки отправки форма вызывает событие `submit`. Мы можем «перехватить» это событие и выполнить проверку.

```html
<script>
  function checkForm(event) {
    var nameText = document.getElementById("name").value;
    if (nameText.length < 1) return false; // форма не отправляется
    return true; // форма отправляется
  }
</script>

<form onsubmit="return checkForm(event)" method="GET" id="poll">
  <input type="text" id="name" />
  <input type="submit" value="Send" />
</form>
```

> **Обратите внимание: return обязательно**. Без него результат функции не повлияет на отправку формы.

#### **Способ 2: Обработка события submit через JavaScript (addEventListener)**

Более современный и гибкий способ — назначить обработчик через `JS-код`:

```javascript
document.getElementById("poll").addEventListener("submit", checkForm);

function checkForm(event) {
  event.preventDefault(); // отключаем стандартную отправку
  var nameText = document.getElementById("name").value;
  if (nameText.length > 0) {
    document.getElementById("poll").submit(); // отправляем вручную
  }
}
```

> ✅ Такой способ отделяет HTML и логику JS — хорошая практика в реальных проектах.

#### **Способ 3: Использование обычной кнопки вместо submit**

Можно убрать `<input type="submit">` и заменить его на обычную кнопку:

```html
<form id="poll">
  <input type="text" id="name" />
</form>
<input type="button" value="Send" onclick="checkButtonClick()" />
```

```javascript
function checkButtonClick() {
  var nameText = document.getElementById("name").value;
  if (nameText.length > 0) {
    document.getElementById("poll").submit();
  }
}
```

> ⚠️ В этом случае форма не отправляется по `Enter`, что может быть нежелательно для `UX`. Также, если забыть отменить `onsubmit`, форма может всё равно уйти, даже без проверки.

### Примечания и советы:

- Метод `submit()` **не вызывает `onsubmit`**. Это означает, что вся проверка должна быть завершена до этого вызова.
- **Объединяйте все проверки в одну функцию**: не делите их на обработчик click и submit.
- Если вы используете JavaScript для проверки, **не забывайте о пользователях, у которых он может быть отключён**.

### Этап 3: Проверка на стороне сервера

Независимо от того, как тщательно реализована клиентская проверка, её можно обойти:

- **отключить JS**;
- **вручную отправить запрос**;
- **изменить HTML в DevTools**.

> Поэтому на сервере необходимо повторно проверять данные. Это правило безопасности: клиентскую валидацию легко обойти, а сервер — последняя линия защиты.

## 2. Объект `RegExp`. Правила записи регулярных выражений

После того как мы научились перехватывать отправку формы и внедрять собственные обработчики, следующий логичный шаг — более сложная и точная проверка введённых пользователем данных.

В предыдущем разделе мы рассматривали простейшую проверку: анализ длины строки, чтобы убедиться, что поле не пустое. Эти проверки полезны, но совершенно не подходят для реальных задач, где важна структура и формат введённых данных.

**Например**:

- **адрес электронной почты должен содержать символ @ и точку**;
- **номер телефона должен состоять только из цифр**;
- **имя не должно содержать цифр и спецсимволов**.

Для таких задач нужны **шаблоны** — **универсальные формальные описания структуры данных**. И здесь нам на помощь приходят **регулярные выражения** — один из мощнейших инструментов обработки строк в программировании.

### Что такое регулярные выражения?

**Регулярное выражение (`Regular Expression`, `RegExp`) — это специальный язык для составления шаблонов**, с помощью которых можно:

- **проверять строки на соответствие заданному формату**;
- **извлекать подстроки**;
- **заменять части строки**;
- **разбивать строку на фрагменты**.

> В JavaScript регулярные выражения реализованы через встроенный объект `RegExp`.

### Почему они удобны для проверки форм?

Все данные, вводимые в форму, приходят как строки. Даже числа (например, возраст) передаются как строки. Это связано с тем, что HTTP-протокол работает с текстовыми данными.

Регулярные выражения позволяют проверять строки по признакам: "цифра", "буква", "не-буква", "пробел", "конец строки" и т.д.

**Можно легко описать шаблон, который проверит**:

- содержит ли строка только цифры;
- начинается ли строка с заглавной буквы;
- есть ли в строке запрещённые символы и т.д.

### Шаблон, маска, флаг — основные термины

#### ✅ **Шаблон (или маска)**

Это описание структуры строки, которой должны соответствовать введённые данные. В терминологии регулярных выражений используются термины:

- **шаблон** (по аналогии с образцом, которому должен соответствовать объект);
- **маска** (по аналогии с битовой маской — набором условий, которые нужно проверить).

Пример:

- шаблон `\d{3}` означает "три подряд идущие цифры";
- шаблон `^[A-Z]` — "строка должна начинаться с заглавной буквы".

#### ✅ **Флаг**

**Флаг — это дополнительное условие работы регулярного выражения**. Примеры:

- `i` — игнорировать регистр (а = А);
- `g` — глобальный поиск (найти все вхождения, а не только первое);
- `m` — многострочный режим (^ и $ будут применяться к каждой строке отдельно).

> Аналогия: шаблон — это форма для фигурки, а флаги — дополнительные правила, как именно вставлять фигурку: можно ли повернуть, учитывать ли цвет, размер и т.д.

### Способы создания регулярного выражения в JavaScript

В языке JavaScript есть два основных способа создать регулярное выражение:

#### **1. Литерал регулярного выражения**

Это более удобный и читаемый способ. Выражение заключается между двумя прямыми слешами /, а после закрывающего слеша могут быть указаны флаги.

- Синтаксис:

  ```javascript
  /шаблон/флаги
  ```

- Пример:

  ```javascript
  var template1 = /\D/;
  ```

  - \D — шаблон (все символы, кроме цифр);
  - флаги отсутствуют.

> Такой шаблон можно сразу применять к строкам.

#### **2. Конструктор `RegExp`**

Если шаблон нужно создать динамически — на основе переменной или результата вычисления, используется конструктор.

- Синтаксис:

  ```javascript
  new RegExp("шаблон", "флаги");
  ```

  > Обратите внимание: в конструкторе не нужны слеши и шаблон и флаги указываются как строки.

- Пример:

  ```javascript
  var template2 = new RegExp("\\D", "g");
  ```

  > Здесь двойной слеш `\\D` — потому что внутри строки слеш нужно экранировать. Такой шаблон тоже ищет не-цифры, но с флагом g (глобальный поиск по всей строке).

### Сравнение способов создания

| Способ          | Когда использовать                | Преимущества                    |
| --------------- | --------------------------------- | ------------------------------- |
| **Литерал**     | Шаблон известен заранее           | Читабельность, простота         |
| **Конструктор** | Шаблон составляется из переменных | Динамическое создание выражений |

> Важно: **независимо от способа создания, применение шаблонов одинаково**. Различие лишь в момент создания — литералы создаются при загрузке скрипта, конструктор — во время выполнения.

### Проверка строки методом `test`

Основной метод для проверки строки на соответствие шаблону — это метод `.test()` объекта `RegExp`.

#### **Синтаксис**:

```javascript
regexp.test(string);
```

- возвращает `true`, если строка соответствует шаблону;
- возвращает `false` — если нет.

#### **Пример**:

```javascript
var template = /\D/; // Шаблон: любой символ, не являющийся цифрой

if (template.test("abc123")) {
  alert("test passed");
} else {
  alert("test failed");
}
```

#### **Проверка в консоли разработчика**

Для выполнения коротких экспериментов с регулярками удобно использовать консоль браузера (F12 → вкладка Console).

Вводим:

```javascript
template = /1/;
```

Шаблон: **ищем наличие цифры 1 в строке**.

Проверим несколько строк:

```javascript
template.test("123"); // true
template.test("234"); // false
template.test("I am 21 years old"); // true
```

Обратите внимание:

- Положение цифры в строке не имеет значения.
- Строка "234" не содержит единицы, поэтому результат false.

Теперь усложним шаблон:

```javascript
template = /12/;
```

Проверка:

```javascript
template.test("123"); // true
template.test("234"); // false
template.test("I am 21 years old"); // false
```

> Строка должна содержать именно подстроку "12" — подряд, в указанном порядке. Простого наличия цифр 1 и 2 недостаточно.

### Специальные символы (метасимволы)

Регулярные выражения поддерживают метасимволы — специальные обозначения групп символов. Это мощный инструмент для обобщения условий.

| Выражение | Значение                                                             |
| --------- | -------------------------------------------------------------------- |
| `\d`      | Любая цифра (0–9)                                                    |
| `\D`      | Всё, что **не цифра**                                                |
| `\s`      | Пробельный символ (пробел, табуляция, перевод строки)                |
| `\S`      | Всё, что **не пробел**                                               |
| `\w`      | Любая буква (латиница), цифра или подчёркивание                      |
| `\W`      | Всё, что **не \w**                                                   |
| `.`       | Любой символ, кроме перевода строки                                  |
| `\x`      | Специальная escape-последовательность для шестнадцатеричных символов |

Примеры:

```javascript
/\d/.test("123") // true — строка содержит цифру
/\D/.test("abc") // true — строка содержит нецифры
/\s/.test("hello world") // true — пробел между словами
/\w/.test("name_1") // true — буквы и подчеркивание
```

> 💡 Подобные шаблоны особенно удобны при проверке имён, телефонов, email и других строк с определённой структурой.

### Собственные наборы символов — квадратные скобки `[]`

Можно задавать свои наборы допустимых символов с помощью [].

Пример:

```js
template = /[12]/; // любой символ "1" или "2"
template.test("123"); // true
template.test("345"); // false
```

Порядок символов не имеет значения:

```js
/[12]/ и /[21]/ — одно и то же.
```

#### **Диапазоны значений в скобках**

Символы можно задавать интервалами:

| Шаблон     | Значение                              |
| ---------- | ------------------------------------- |
| `[1-4]`    | Любая цифра от 1 до 4                 |
| `[a-z]`    | Любая строчная английская буква       |
| `[A-Z]`    | Любая заглавная английская буква      |
| `[г-ж]`    | Любая буква от «г» до «ж» (в Unicode) |
| `[0-9A-F]` | Любая 16-ричная цифра: 0–9, A–F       |

Пример:

```js
template = /[A-Z]/;
template.test("small letters"); // false
template.test("one Big letter"); // true
```

#### Исключающие наборы — [^]

Если в начале скобок указать ^, это будет означать отрицание — шаблон сработает, если символ не входит в набор.

Пример:

```js
template = /[^123]/;
template.test("123"); // false
template.test("123abc"); // true (буквы не входят в список)
template.test("0"); // true (0 не входит в [123])
```

#### Квантификаторы (указатели количества)

После символа или группы символов можно указать количество повторений:

| Квантификатор | Значение          |
| ------------- | ----------------- |
| `?`           | 0 или 1 раз       |
| `+`           | 1 или более раз   |
| `*`           | 0 или более раз   |
| `{n}`         | ровно `n` раз     |
| `{n,}`        | `n` и более раз   |
| `{n,m}`       | от `n` до `m` раз |

Примеры:

```js
/\d{3}/.test("123"); // true (три цифры подряд)
/\d{2,4}/.test("1234"); // true (от двух до четырёх цифр)
/a+/.test("aaa"); // true (одна или более букв a)
/a*/.test("bbb"); // true (ноль букв a — тоже подходит)
```

> Важно: Квантификатор применяется только к символу или группе, стоящей перед ним. Он не влияет на предыдущие или последующие символы.

### Якоря (Anchors)

Символы-якоря задают позицию в строке, а не конкретный символ:

| Якорь | Значение      |
| ----- | ------------- |
| `^`   | начало строки |
| `$`   | конец строки  |

Пример:

```js
/^1/          // Строка начинается с «1»
/\d$/         // Строка заканчивается цифрой
```

> 🔔 Внимание: Символ ^ играет двойную роль:

- `вне скобок []` — означает начало строки
- `внутри [^...]` — означает исключение (НЕ включать)

#### Практика

- ✅ Проверка, что строка начинается с 1:
  ```js
  template = /^1/;
  template.test("123abc"); // true
  template.test("a123"); // false
  ```
- ✅ Проверка, что строка заканчивается на:

  - `4`:

    ```js
    template = /4$/;
    template.test("abc4"); // true
    ```

  - `d`:

    ```js
    template = /d$/;
    template.test("good"); // true
    ```

  - любую цифру:

    ```js
    template = /\d$/;
    template.test("value7"); // true
    ```

### Экранирование специальных символов

Многие символы в регулярных выражениях имеют особое значение, например `+, *, ^, $, ., [], {}, ()` и т.д.

Чтобы использовать сам символ, а не его специальное значение, его экранируют с помощью обратного слеша `\`.

#### Пример:

```js
/\$/; // Ищет символ "$"
```

Если не экранировать:

```js
/$/; // Ищет конец строки, а не символ "$"
```

#### Практика:

```js
template = /$/;
template.test("$20 is better than $10"); // true
template.test("20 is better than 10"); // тоже true — всегда есть конец строки

template = /\$/;
template.test("$20 is better than $10"); // true
template.test("20 is better than 10"); // false
```

### Ошибка и разбор

**Задача**: Проверить, что строка соответствует номеру телефона в международном формате: +380512670053

- Условия:

  - Строка должна начинаться с + → `^+`
  - За ним 12 цифр → `\d{12}`
  - И больше ничего → `$`

- Ошибочный шаблон:

  ```js
  /^+\d{12}$/; // ❌ Неверно: + — это квантификатор
  ```

- Правильный шаблон (с экранированием):

  ```js
  /^\+\d{12}$/; // ✅ Экранирован символ «+»
  ```

## 3. Методы объектов RegExp и String для работы с регулярными выражениями

В предыдущем разделе мы разобрали синтаксис регулярных выражений: как создавать шаблоны, применять символы и квантификаторы. Теперь рассмотрим как использовать эти шаблоны в JavaScript — при помощи методов объектов `RegExp` и `String`.

### 🔍 Объект `RegExp` и его методы

Объект RegExp представляет собой регулярное выражение. Создается он двумя способами:

#### 📌 **1. Через литерал**:

```js
const pattern = /\d+/g;
```

#### 📌 **2. Через конструктор RegExp**:

```js
const pattern = new RegExp("\\d+", "g");
```

> ⚠ В конструкторе обратный слеш необходимо дублировать, так как он экранируется в строке.

#### ✅ **Метод `test`**

Метод `test()` используется для проверки, соответствует ли строка заданному регулярному выражению.

```js
pattern.test("abc123"); // true
pattern.test("abc"); // false
```

> Возвращает `true` или `false`.

#### ✅ **Метод `exec`**

Метод `exec()` позволяет получить информацию о совпадении — он не просто проверяет, но и возвращает:

- найденный фрагмент;
- его позицию в строке (`index`);
- исходную строку.

```js
const str = "20% of population owning 80% income";
const template = /\d+/;

const result = template.exec(str);
console.log(result);
```

Результат — объект (массивоподобный):

```js
[
  "20",         // [0] — совпавшая подстрока
  index: 0,     // позиция в строке
  input: "20% of population owning 80% income",
  groups: undefined
]
```

> 📎 Метод `exec` возвращает только первое совпадение (если не используется флаг g).

#### 🔁 **Повторный вызов `exec` без флага `g`**

```js
template.exec(str); // снова вернёт "20"
```

> Повторный вызов без флага g приведёт к тому же результату — поиск всегда начинается с начала строки.

#### 🚩 **Флаг `g` — глобальный поиск**

Чтобы `exec()` искал все совпадения, а не только первое, используйте флаг g:

```js
const template = /\d+/g;
```

> Теперь метод `exec()` будет запоминать, где остановился, и возвращать следующие совпадения при каждом вызове:

```js
template.exec(str); // вернёт "20"
template.exec(str); // вернёт "80"
template.exec(str); // вернёт null (больше чисел нет)
```

> Каждое выполнение метода возвращает следующее совпадение, пока они есть.

##### 🧠 Важно: если вы снова вызовете `exec()` на той же строке и с тем же шаблоном, поиск продолжится с позиции, следующей за последним найденным фрагментом. Это возможно благодаря внутреннему свойству `lastIndex`.

#### ✅ **Задание: Найти все числа в строке с помощью цикла**

Для этого удобно использовать `while` и проверять, не `null` ли результат:

```js
const str = "20% of population owning 80% income";
const template = /\d+/g;
let match;

while ((match = template.exec(str)) !== null) {
  console.log(`Найдено число: ${match[0]}, позиция: ${match.index}`);
}
```

#### 📌 Результат:

```
Найдено число: 20, позиция: 0
Найдено число: 80, позиция: 25
```

### 🔎 Методы объекта `String`, работающие с регулярными выражениями

В дополнение к методам объекта `RegExp`, регулярные выражения можно применять и с помощью методов объекта `String`. К таким методам относятся:

- `match()`
- `replace()`

#### 📌 **Метод `match(regexp)`**

Метод `match()` проверяет строку на соответствие регулярному выражению и возвращает либо:

- объект с найденными фрагментами (в виде массива), либо
- null, если совпадений не найдено.

> 🧠 Важно: поведение `match()` зависит от наличия флага g в регулярном выражении.

#### 🔁 **Сравнение с `exec()`**

Если метод `RegExp.exec()` вызывается у регулярного выражения:

```js
template.exec(str);
```

то метод `match()` вызывается у строки:

```js
str.match(template);
```

Здесь шаблон передаётся как аргумент.

#### ✅ **Пример без флага `g`:**

```js
const str = "20% of population owning 80% income";
const template = /\d+/;

const result = str.match(template);
console.log(result);
```

Результат:

```js
[
  "20",         // [0] — совпавшая подстрока
  index: 0,     // позиция в строке (в отладчике, неявно)
  input: "20% of population owning 80% income"
]
```

> Поведение аналогично методу `exec()`, но позиция совпадения (`index`) не видна напрямую в ответе.

#### ✅ Пример с флагом g:

```js
const template = /\d+/g;
const result = str.match(template);
console.log(result);
```

Результат:

```js
["20", "80"];
```

- При наличии флага g:

  - `match()` возвращает массив всех совпадений сразу;
  - информация о позициях (`индексах`) не возвращается.

#### 📌 **Что выбрать: `exec()` или `match()`**?

| Метод     | Что возвращает                          | Подходит для                       |
| --------- | --------------------------------------- | ---------------------------------- |
| `exec()`  | Объект с совпадением и его позицией     | Когда важна **позиция** совпадения |
| `match()` | Массив совпадений (или одно совпадение) | Когда важны **только совпадения**  |

#### 🔄 **Метод `replace(pattern, replacement)`**

Метод `replace()` позволяет заменить найденные в строке фрагменты на другое значение.

- ✅ **Пример: очистка номера телефона от тире**

```js
const str = "67-00-53";
const result = str.replace("-", "");
console.log(result);
```

Результат:

```
670053
```

> Нет, подождите… это ошибка! Фактический результат будет:

```yaml
6700-53
```

> ❗ `replace()` без флага g заменяет только первое совпадение.

#### 📌 Замена всех совпадений: используем регулярное выражение с флагом g

```js
const result = str.replace(/-/g, "");
console.log(result);
```

Результат:

```
670053
```

> Теперь все тире удалены.

#### **`String.match()`, `RegExp.exec()`, `String.replace()`**

- Метод `String.match()` удобен, если нужны все совпадения сразу, без забот о цикле.
- Метод `RegExp.exec()` — полезен, если нужно пошагово обрабатывать совпадения или знать их позиции в строке.
- Метод `String.replace()` позволяет заменять части строки. При использовании с флагом g можно заменить все совпадения.

#### 🔍 Расширенные шаблоны для поиска: группы символов

Иногда требуется искать несколько разных символов — например, и тире, и пробелы. В таких случаях используют группы символов в квадратных скобках:

```js
/[- ]/g;
```

> Здесь символ `-` и `пробел` объединены в группу: будет найден любой из них. Квадратные скобки `[ ]` означают "любой из перечисленных символов".

#### ✅ Пример: удаление тире и пробелов

```js
const str = "67 - 00 - 53";
const cleaned = str.replace(/[- ]/g, "");
console.log(cleaned); // "670053"
```

Результат: из строки удалены все пробелы и тире.

#### ✂ **Метод `split(separator)`**

Метод `split()` разбивает строку на массив подстрок по заданному разделителю:

```js
str.split(разделитель);
```

разделитель может быть обычной строкой или регулярным выражением.

Метод возвращает массив строк.

#### ✅ **Пример: делим строку по запятой**

```js
const data = "apple,banana,pear";
const parts = data.split(",");
console.log(parts); // ["apple", "banana", "pear"]
```

> ⚙ Регулярное выражение как разделитель. Часто разделителями бывают разные символы, включая пробелы, запятые и их комбинации. Здесь особенно полезны регулярные выражения.

#### ✅ **Пример: разделение имени и фамилии**

```js
const str1 = "Smith John";
const str2 = "Smith,  John";

// Разделитель: один или более символов, не входящих в состав слов
const template = /\W+/;

console.log(str1.split(template)); // ["Smith", "John"]
console.log(str2.split(template)); // ["Smith", "John"]
```

- `\W` — означает любой небуквенно-цифровой символ.
- `+` — квантификатор: один или более раз подряд.
- Результат: обе строки корректно разбиты на фамилию и имя.

#### **Пример: разделение нескольких номеров**

Допустим, пользователь может ввести несколько номеров, разделённых запятой и пробелами:

```arduino
"67-00-53 ,  670053 , +380512670053"
```

Наша задача — получить массив номеров.

Решение:

```js
const str = "67-00-53 ,  670053 , +380512670053";
const phones = str.split(/\s*,\s*/);
console.log(phones);
// ["67-00-53", "670053", "+380512670053"]
```

- `\s*` — ноль или более пробельных символов.
- `,` — разделитель номеров.

> Таким образом, мы допускаем пробелы перед и после запятой.

#### **`replace()`, `split()`, Группы `[...]`**

| Метод          | Назначение                         | Пример шаблона          |
| -------------- | ---------------------------------- | ----------------------- |
| `replace()`    | Замена символов или групп символов | `/[- ()]/g`             |
| `split()`      | Разделение строки по шаблону       | `/\W+/` или `/\s*,\s*/` |
| Группы `[...]` | Поиск любых символов из набора     | `[- ]`, `[- ()]`        |

#### 🔤 **Флаг `i`: регистронезависимый поиск**

Один из часто используемых флагов в регулярных выражениях — это флаг `i`, означающий:

- `регистронезависимость` — сравнение не различает большие и маленькие буквы.

#### 🔎 **Без `i`: чувствительность к регистру**

Обычное регулярное выражение различает `"Yes"` и `"yes"`:

```js
const template = /yes/;

template.test("Yes, of course"); // false
template.test("yes, of course"); // true
```

#### ✅ **С `i`: игнорируем регистр**

С флагом i шаблон будет реагировать на любые комбинации регистра:

```js
const template = /yes/i;
```

Теперь протестируем несколько строк:

```js
const str1 = "Yes, of course";
const str2 = "well, let it be yes";
const str3 = "I said YES!";

console.log(template.test(str1)); // true
console.log(template.test(str2)); // true
console.log(template.test(str3)); // true
```

#### ❌ Строки без совпадения

Проверим строки, не содержащие слова `yes`:

```js
console.log(template.test("good")); // false
console.log(template.test("OK")); // false
```

#### 🧠 Пример: подтверждение согласия

Рассмотрим практическую задачу: мы хотим от пользователя подтверждение согласия, написанное как угодно, но содержащее "yes" в любом регистре:

```js
function isConfirmed(input) {
  return /yes/i.test(input);
}

isConfirmed("YES"); // true
isConfirmed("Yes, of course"); // true
isConfirmed("ok"); // false
```

> Это позволяет эффективно обрабатывать ввод пользователя, не беспокоясь о различиях между `"YES"`, `"yes"`, `"Yes"`, и так далее.

| Флаг    | Назначение                                  | Пример                                     |
| ------- | ------------------------------------------- | ------------------------------------------ |
| `i`     | Игнорирует регистр символов                 | `/yes/i` находит `"YES"`, `"yes"`, `"Yes"` |
| без `i` | Строгое сравнение, чувствительно к регистру | `/yes/` найдёт только `"yes"`              |

## 4. Проверка достоверности данных формы на практике

Регулярные выражения (RegExp) позволяют не только обрабатывать строки, но и проверять корректность данных, вводимых в формы. В этом разделе мы рассмотрим практические примеры валидации данных с помощью HTML и JavaScript — на примере формы регистрации нового пользователя.

### 📄 Подготовка HTML-страницы с формой

Создадим HTML-документ с формой, в которую пользователь будет вводить:

- **Имя и фамилию**
- **Логин**
- **Пароль и его подтверждение**
- **Адрес электронной почты**
- **Телефон**
- **Проверочный код**
- **Галочку согласия с правилами**

🔧 HTML-код формы:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Registration form</title>
    <style>
      #regForm b {
        display: inline-block;
        padding-top: 5px;
        width: 100px;
      }
      #regForm input[type="submit"] {
        margin: 15px 150px;
      }
    </style>
  </head>
  <body>
    <form method="GET" id="regForm" onsubmit="return checkForm()">
      <b>First name:</b>
      <input type="text" id="name1" name="name1" required /><br />

      <b>Last name:</b>
      <input type="text" id="name2" name="name2" required /><br />

      <b>Login:</b>
      <input type="text" id="login" name="login" required /><br />

      <b>Password:</b>
      <input type="password" id="pas1" name="pass" required /><br />

      <b>Confirm password:</b>
      <input type="password" id="pas2" required /><br />

      <b>Email:</b>
      <input type="email" id="email" name="email" required /><br />

      <b>Phone number:</b>
      <input type="phone" id="phone" name="phone" required /><br />

      <b>Code:</b>
      <input type="number" id="code" name="code" required /><br />

      <b></b>
      <label>
        <input type="checkbox" name="accept" required />
        I accept the rules </label
      ><br />

      <input type="submit" value="Register" />
    </form>

    <script>
      function checkForm() {
        alert("Analyzing...");
        return false;
      }
    </script>
  </body>
</html>
```

> 📎 Сохраните файл под именем, например, `form.html`, и откройте его в браузере. Вы увидите форму регистрации с полями, готовыми к заполнению.

### 📌 Особенности структуры формы

#### **1. Атрибут required**

Каждое поле ввода (за исключением кнопки) содержит атрибут required. Он означает:

> ⚠️ Поле обязательно к заполнению. Если оставить его пустым, браузер выдаст встроенное сообщение и не отправит форму.

🧪 **Попробуйте**: нажмите кнопку "Register", не заполняя форму — появится предупреждение.

> ❗ Однако важно понимать: браузер проверяет только наличие ввода, а не его содержание. Если ввести один пробел в поле, браузер считает его заполненным. Это формально корректное значение, но по сути — пустое.

#### **2. Использование типов `<input>`**

Выбор типа поля помогает переложить часть валидации на браузер:

| Поле        | Тип поля          | Поведение                                                  |
| ----------- | ----------------- | ---------------------------------------------------------- |
| Пароль      | `type="password"` | Вводимые символы скрываются                                |
| Email       | `type="email"`    | Проверяется наличие `@` и корректного домена               |
| Телефон     | `type="phone"`    | Не валидируется браузером (требуется собственная проверка) |
| Код (число) | `type="number"`   | Допускает только числовой ввод                             |

> **Попробуйте**: введите в поле Email значение 1 и нажмите "Register" — браузер покажет сообщение об ошибке.

#### 💡 Почему этого недостаточно?

- Атрибут required не проверяет корректность содержимого.
- Тип text принимает любые символы.
- Браузерная валидация ограничена: она не позволяет задать детальные требования к формату.

### Перехват события отправки формы

Для начала полноценной проверки данных, введённых пользователем, необходимо перехватить событие отправки формы. Это делается с помощью атрибута `onsubmit`, который добавляется к тегу `<form>`. Он указывает функцию JavaScript, которую необходимо вызвать при попытке отправки формы.

Пример:

```html
<form method="GET" id="regForm" onsubmit="return checkForm()"></form>
```

Здесь указано, что при отправке формы будет вызвана функция `checkForm()`. Она должна вернуть `true`, если данные корректны и форму можно отправить, либо `false`, если нужно отменить отправку.

#### Теперь создадим простую заготовку этой функции:

```javascript
function checkForm() {
  alert("Analyzing...");
  return false;
}
```

#### Зачем нужен `return false`?

Это позволяет отменить действие по умолчанию — в данном случае, отправку формы. Это удобно, чтобы сначала проверить данные, и только если всё в порядке, разрешить отправку.

Проверьте:

- Заполните форму любыми данными.
- Нажмите на кнопку `"Register"`.
- Появится сообщение `Analyzing...`, и форма не отправится: **URL в адресной строке не изменится, и данные в полях останутся**.
  > Таким образом, мы получили возможность полностью контролировать процесс отправки данных, выполняя предварительную проверку.

### Начало анализа данных: использование регулярных выражений

Следующий этап — анализ содержимого полей с помощью регулярных выражений (регулярных выражений / regex).

**Важно**: перед тем как составить регулярное выражение, нужно чётко определить требования к данным. Частая ошибка — начинать писать шаблон, не понимая, что именно должно быть допустимо, а что — нет.

### **Проверка имени**

#### **Пример 1. Простая проверка имени: только английские буквы**

##### **Условие**:

Имя должно содержать только английские буквы, без пробелов, тире, цифр и т.д.

Такой шаблон проще всего составить "от противного" — ищем наличие символов, которых быть не должно.

```javascript
var t1 = /[^a-z]/i;
```

- `[^a-z]` — означает любой символ, кроме букв от a до z.
- Флаг `i` — означает игнорирование регистра: допускаются как заглавные, так и строчные буквы.

##### **Добавим проверку в `checkForm()`**:

```javascript
function checkForm() {
  var n1 = document.getElementById("name1").value;
  var t1 = /[^a-z]/i;
  if (t1.test(n1)) {
    alert("First name is incorrect");
    return false;
  }
}
```

> Метод `test()` возвращает `true`, если в строке есть хоть одно совпадение с шаблоном.

##### **Проверьте работу**:

- Введите: John → всё в порядке.
- Введите: John123 или Jo-hn или J@ne → появится предупреждение.

#### **Пример 2. Первая буква имени должна быть заглавной**

Теперь усложним правило:

##### **Условие**:

- Только английские буквы.
- Первая буква — заглавная.
- Остальные — строчные.

Так как теперь важно различать регистр символов, флаг i использовать нельзя.

##### **Создаём регулярное выражение**:

```javascript
var t1 = /^[A-Z][a-z]*$/;
```

- `^` — начало строки.
- `[A-Z]` — одна заглавная буква.
- `[a-z]*` — ноль или более строчных букв.
- `$` — конец строки.

##### **Изменим функцию**:

```javascript
function checkForm() {
  var n1 = document.getElementById("name1").value;
  var t1 = /^[A-Z][a-z]*$/;
  if (!t1.test(n1)) {
    alert("First name is incorrect");
    return false;
  }
}
```

> Обратите внимание на !t1.test(n1) — теперь мы проверяем, что шаблон не соответствует, и только тогда показываем ошибку.

##### **Проверьте работу**:

- `John` — OK.
- `john` — ошибка.
- `JOHN` — ошибка.
- `J0hn` — ошибка.

#### **Пример 3. Составные имена: с тире**

Иногда встречаются составные имена (или фамилии), например: Jean-Paul, Mary-Kate. Такие случаи необходимо тоже учитывать.

##### **Условие**:

Первая часть — заглавная + строчные.

Далее может быть одна или несколько частей, каждая с -Заглавная + строчные.

##### **Пример шаблона**:

```javascript
var t1 = /^[A-Z][a-z]*(-[A-Z][a-z]*)*$/;
```

##### **Разбор**:

- `[A-Z][a-z]*` — первая часть (например, Jean).
- `(-[A-Z][a-z]*)*` — 0 или более повторений составных частей (-Paul, -Claude и т.п.).

##### **Обновим `checkForm()` снова**:

```javascript
function checkForm() {
  var n1 = document.getElementById("name1").value;
  var t1 = /^[A-Z][a-z]*(-[A-Z][a-z]*)*$/;
  if (!t1.test(n1)) {
    alert("First name is incorrect");
    return false;
  }
}
```

##### **Протестируйте**:

- `John` — OK
- `John-Paul` — OK
- `john` — ошибка
- `Jean-Paul-Sartre` — OK
- `Jean-paul` — ошибка (вторая часть должна начинаться с заглавной)

#### **Пример 4. Апострофы, строчные буквы и составные части**

Рассмотрим имена, которые включают апостроф или начинаются с маленькой буквы, как в `d'Artagnan` или `O'Brian`. Такие формы часто встречаются в реальных данных, особенно для фамилий ирландского или французского происхождения.

Также можно встретить написание без апострофа, например: `dArtagnan`, `OBrian`. Это тоже следует считать допустимым вариантом.

##### **Обновлённое правило**:

- Первая буква имени может быть как заглавной, так и строчной.
- После первой буквы может быть апостроф, но необязательно.
- За апострофом следует ещё одна латинская буква.
- Далее — произвольное количество строчных букв до конца строки.

##### **Новый шаблон регулярного выражения**:

```js
/^[A-Za-z]'?[A-Za-z][a-z]*$/;
```

##### 🔍 **Разбор выражения**:

- `^[A-Za-z]` — имя начинается с одной латинской буквы (любой регистр).
- `'?` — за первой буквой может следовать апостроф.
- `[A-Za-z]` — далее обязательно идёт ещё одна латинская буква.
- `[a-z]*$` — оставшиеся символы должны быть строчными буквами, либо может не быть ни одного.

##### **Протестируйте**:

- `d'Artagnan`
- `dArtagnan`
- `OBrian`
- `O'Brian`

#### **Пример 5. Составные фамилии и имена**

Теперь усложним шаблон. Допустим, мы хотим обрабатывать составные имена, включающие дефис (например, `Jean-Paul`, `O'Brian-Smith`).

Используем похожую логику, как в предыдущих шаблонах, но дополним её возможностью включения одной или нескольких частей, разделённых дефисом.

##### **Пример улучшенного шаблона**:

```js
/^[A-Za-z]'?[A-Za-z][a-z]*(?:-[A-Za-z]'?[A-Za-z][a-z]*)*$/;
```

##### 🔍 Разбор дополнения:

- `(?:...)` — группа без сохранения, используемая для повторяющейся конструкции.
- `-[A-Za-z]'?[A-Za-z][a-z]*` — вторая и последующие части, аналогично первой, но начинаются с дефиса.
- `* после группы` — допускается ноль или больше составных частей.

##### 📌 **Протестируйте**:

- `Jean-Paul`
- `O'Brian-Smith`
- `d'Artagnan-LeClerc`

#### Выводы

- **Имена и фамилии имеют множество реальных форм**, и универсальное регулярное выражение для них составить очень сложно.
- **Чем более универсальным становится шаблон, тем больше ложноположительных или ложноотрицательных срабатываний он даёт**.
- Шаблон `/^[A-Z][a-z]*(-[A-Z][a-z]*)*$/` **успешно принимает, например, `A-A-A`**, что **логически не является корректным именем**.

  ```js
  /^[A-Z][a-z]*(-[A-Z][a-z]*)*$/.test("A-A-A"); // true
  ```

- **Универсального шаблона не существует** — всегда найдётся имя, которое нарушает любое формализованное правило.
- Прежде чем писать регулярное выражение, нужно ясно **определить требования**. Иначе шаблон будет бесконечно усложняться и всё равно давать ошибки.

### **Проверка пароля**

Теперь рассмотрим другую важную часть формы — проверку надёжности пароля. В отличие от имён, требования к паролю можно задать жёстко и однозначно.

#### **Условия**:

Пароль должен содержать:

- **хотя бы одну цифру**
- **хотя бы одну заглавную букву**
- **хотя бы одну строчную букву**

Мы не ограничиваем длину и не запрещаем другие символы, но все три типа символов обязательны.

#### **Проверка: «от противного»**

Проверку выполняем не по одному общему шаблону, а тремя отдельными, чтобы выяснить, чего в пароле не хватает.

```js
var p1 = document.getElementById("pas1").value;

if (!/\d/.test(p1)) {
  alert("Password has no digit");
}
if (!/[A-Z]/.test(p1)) {
  alert("Password has no big letters");
}
if (!/[a-z]/.test(p1)) {
  alert("Password has no small letters");
}
```

📌 Пояснение:

- `/\d/` — проверяет наличие цифры
- `/[A-Z]/` — заглавной латинской буквы
- `/[a-z]/` — строчной латинской буквы

> Все три проверки независимы. Это позволяет точно указать пользователю, чего не хватает, а не просто говорить «пароль неверен».

#### **Подтверждение пароля**

Не забудьте реализовать проверку совпадения основного и повторного ввода пароля.

```js
var p2 = document.getElementById("pas2").value;

if (p1 !== p2) {
  alert("Passwords do not match");
}
```

> Эта проверка не требует регулярного выражения — достаточно обычного сравнения строк.

### **Проверка электронной почты**

Проверка валидности адреса электронной почты — одна из самых обсуждаемых и противоречивых тем в веб-разработке. На это есть несколько причин:

#### 1. **Постоянно меняющиеся стандарты**

Формат адресов электронной почты регулируется стандартами (например, RFC 5322), которые со временем дополняются, пересматриваются или устаревают. Это означает, что выражение, которое считалось допустимым ранее, может быть признано недействительным — и наоборот. Поэтому регулярные выражения для проверки email могут отличаться в зависимости от того, насколько строго или гибко нужно проверять введённые данные.

#### 2. **Внутренние и внешние адреса**

Внутренние системы могут использовать упрощённые адреса, например:

```text
user@localhost
```

Это допустимый email в рамках локальной инфраструктуры. Однако для адресов, отправляемых по интернету, обязателен домен второго уровня, например:

```text
user@itstep.org
```

Таким образом, одинаковое регулярное выражение не может одинаково корректно обрабатывать внутренние и внешние адреса — необходимо учитывать контекст.

#### 3. **Реализация стандартов почтовыми серверами**

Даже если стандарт допускает определённый формат, это не означает, что его поддерживает каждый почтовый сервер. Например, технически валидным является адрес с пробелом перед символом «@»:

```text
 @itstep.org
```

Хотя стандарт его разрешает, ни один реальный сервер не позволит создать такой почтовый ящик. Также, по спецификации, email-адреса могут быть регистрозависимыми:

```text
user@itstep.org ≠ User@itstep.org
```

Но большинство серверов игнорируют регистр, особенно в части имени пользователя (до @). Однако при разработке важно учитывать, что технически адреса считаются разными.

#### **Пример регулярного выражения для базовой проверки email**:

```js
/^\w+([-+.’]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;
```

#### **Разбор выражения по частям**

| Часть выражения | Объяснение                                                               |
| --------------- | ------------------------------------------------------------------------ |
| `^`             | Начало строки                                                            |
| `\w+`           | Одна или более букв, цифр или подчеркиваний (буквенно-цифровой символ)   |
| `([-+.’]\w+)*`  | Допускаются группы: дефис/плюс/точка/апостроф, за которыми следует \w+   |
| `@`             | Символ «@» — обязательный разделитель имени и домена                     |
| `\w+([-.]\w+)*` | Имя домена — допустимы дефисы и точки                                    |
| `\.`            | Точка перед доменной зоной                                               |
| `\w+([-.]\w+)*` | Доменная зона (например, «com», «org»), также может включать дефис/точку |
| `$`             | Конец строки                                                             |

> ⚠️ Важно: в выражении используется символ ’ (типографская кавычка), который следует заменить на обычную ', если вы копируете выражение.

#### **Реализация в JavaScript**

Пример использования шаблона в проверке формы:

```html
<input type="text" id="email" placeholder="Введите e-mail" />
<button onclick="checkForm()">Проверить</button>
```

```js
function checkForm() {
  const eMail = document.getElementById("email").value;
  const te = /^\w+([-+.’]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;

  if (!te.test(eMail)) {
    alert("e-Mail is incorrect");
  }
}
```

> ✅ **Примечание**: браузер автоматически выполняет базовую проверку, если у `<input>` установлен `type="email"`. Чтобы полностью проверить своё регулярное выражение, замените тип на `text`.

Попробуйте ввести: `user*2@itstep.org`

### **Проверка номера телефона**

Требования:
начинаться с `+`,

- содержать только цифры и дефисы,
- длина — не менее 10 символов

Пример:

```js
/^\+?\d{10,15}$/;
```

### **Проверка кода подтверждения**

Рассмотрим простой случай — код подтверждения, который должен содержать только цифры.

HTML-разметка:

```html
<input type="text" id="code" placeholder="Введите код подтверждения" />
```

JS-проверка:

```js
function checkCode() {
  const code = document.getElementById("code").value;
  const codePattern = /^\d+$/;

  if (!codePattern.test(code)) {
    alert("Код подтверждения должен содержать только цифры");
  }
}
```

> Такой шаблон допускает любое количество цифр (по крайней мере одну). При необходимости можно ограничить длину, например от 4 до 6 цифр: `/^\d{4,6}$/`

### **Проверка чекбокса на согласие**

Последний элемент, подлежащий проверке — это чекбокс согласия с корпоративными правилами. В отличие от проверки имени, пароля или `email`, здесь не требуется использование регулярных выражений. Достаточно проверить, установлена ли галочка (чекбокс отмечен), а это означает, что его значение равно `"on"`.

```js
var agree = document.getElementById("accept").value;
if (agree != "on") {
  alert("You should accept rules");
  return false;
}
```

> Свойство `value` для чекбокса имеет значение `"on"`, только если пользователь установил галочку. В противном случае значение будет `undefined`, и условие не выполнится.

#### **Альтернативный вариант**

Вместо проверки по `value`, так же корректным считается использование свойства `checked`:

```js
var agree = document.getElementById("accept").checked;
if (!agree) {
  alert("You should accept rules");
  return false;
}
```

### **Завершение проверки и разрешение отправки формы**

После прохождения всех проверок форма может быть успешно отправлена. Для этого из функции `checkForm()` необходимо вернуть `true`, что сигнализирует браузеру о допустимости отправки данных:

```javascript
return true;
```

Если хотя бы одна из проверок не проходит, функция возвращает `false`, и отправка формы прерывается.

#### **Полный пример проверки формы**

Ниже приведён полный скрипт, объединяющий все этапы валидации:

```html
<script>
  function checkForm() {
    var n1 = document.getElementById("name1").value;
    var t1 = /^[A-Z][a-z]*(-[A-Z][a-z]*)*$/;
    if (!t1.test(n1)) {
      alert("First name is incorrect");
      return false;
    }

    var n2 = document.getElementById("name2").value;
    if (!t1.test(n2)) {
      alert("Last name is incorrect");
      return false;
    }

    var p1 = document.getElementById("pas1").value;
    if (!/\d/.test(p1)) {
      alert("Password has no digit");
      return false;
    }
    if (!/[A-Z]/.test(p1)) {
      alert("Password has no big letters");
      return false;
    }
    if (!/[a-z]/.test(p1)) {
      alert("Password has no small letters");
      return false;
    }

    var p2 = document.getElementById("pas2").value;
    if (p1 !== p2) {
      alert("Passwords mismatch");
      return false;
    }

    var eMail = document.getElementById("email").value;
    var te = /^\w+([-+.’]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;
    if (!te.test(eMail)) {
      alert("e-Mail is incorrect");
      return false;
    }

    var phone = document.getElementById("phone").value;
    if (!/^\+?\d{6,12}$/.test(phone)) {
      alert("Phone is incorrect");
      return false;
    }

    var cod = document.getElementById("code").value;
    if (/\D/.test(cod)) {
      alert("Code is incorrect");
      return false;
    }

    var agree = document.getElementById("accept").checked;
    if (!agree) {
      alert("You should accept rules");
      return false;
    }

    return true;
  }
</script>
```

### Поведение страницы при отправке формы

- После успешной отправки формы:
  - Страница перезагружается.
  - Все поля очищаются (если не используется `event.preventDefault()` или `AJAX`).
  - В адресной строке отображаются переданные параметры и их значения, если метод формы — `GET`.
- Если отправка не состоялась:
  - Срабатывает предупреждение от браузера или от нашей функции `checkForm()`.
  - Страница не обновляется.
  - Введённые пользователем данные остаются в полях формы.
  - В адресной строке изменений не происходит.

# Cookies

## 1. Что такое cookie?

Перейдём ко второй части **процесса обмена данными** между клиентом и сервером. Если первая часть касалась отправки информации от клиента на сервер — в основном с помощью HTML-форм, то вторая часть — это **обратный процесс**, то есть **получение клиентом ответа от сервера**.

### Проблема отсутствия "памяти" у сервера

Одной из ключевых особенностей, которая влияет на формирование сервером ответа, является то, что **сервер не запоминает предыдущее взаимодействие с клиентом**. Каждый запрос рассматривается как **уникальный и независимый**, даже если он пришёл от того же самого клиента, что и раньше.

**В HTTP-протоколе** (основе взаимодействия в вебе) отсутствует **встроенная "память" о прошлых соединениях**. Соединение устанавливается, клиент и сервер обмениваются данными, и после завершения соединения обе стороны «забывают» друг о друге.

Это значит, что:

- если пользователь авторизовался на сайте, на следующем запросе сервер уже не "помнит", кто он;
- если пользователь выбрал товары в корзину, при обновлении страницы корзина может сброситься, если информация о сеансе не сохраняется.

### Почему нельзя полагаться на IP-адрес

Можно предположить, что сервер может **различать пользователей по IP-адресу**, но это ненадёжный способ:

#### 1. IP-адрес может изменяться. Например:

- У мобильных пользователей при переходе между сотовыми вышками.
- При переподключении к сети.

#### 2. Несколько клиентов могут иметь одинаковый внешний IP-адрес, например:

- Сотрудники одного офиса, подключённые через общий прокси-сервер.
- Пользователи публичного Wi-Fi.

> **Итог**: если использовать только IP для идентификации, можно перепутать пользователей и нарушить корректность работы сайта.

### Решение: **идентификатор сеанса** (Cookie)

Чтобы **различать пользователей и связывать запросы с предыдущими сессиями, сервер может отправить клиенту уникальный идентификатор** — небольшой фрагмент данных, который сохраняется в браузере клиента. **При следующих запросах клиент будет автоматически возвращать эти данные на сервер**.

Такой механизм и получил название `cookie` (от англ. cookie — печенье, но перевод не используется).

### Особенности `Cookie`

- Cookie похожи на `POST-данные`, но они **не видны в адресной строке браузера**.
- Cookie **хранятся на стороне клиента**, в браузере.
- Они **автоматически добавляются ко всем запросам**, отправляемым к серверу, пока не истечёт их срок действия.
- Пользователь **не участвует в процессе обработки `cookie`** — всё делает браузер.
- **Cookie не влияют на внешний вид страницы**, они используются исключительно для обмена информацией между клиентом и сервером.

### Как устанавливаются `Cookie`

Cookie могут быть установлены как сервером, так и клиентом (через JavaScript):

- Сервер может включить заголовок **Set-Cookie в HTTP-ответ**.
- JavaScript на странице может **использовать объект `document.cookie` для создания, чтения и удаления `cookie`**.

> Независимо от того, кто установил cookie — сервер или клиент — они будут включаться в все последующие HTTP-запросы к этому же серверу, пока не истекут или не будут удалены.

### Практический смысл

Cookie — это механизм, который:

- **позволяет реализовать аутентификацию** (вход в аккаунт и его сохранение);
- **обеспечивает сохранение состояния** (корзина, настройки сайта);
- **используется для аналитики и трекинга** (что пользователь делал ранее);
- **облегчает персонализацию** (отображение нужной валюты, языка и др.).

### Резюме

| Свойство        | Описание                                                        |
| --------------- | --------------------------------------------------------------- |
| Хранятся        | В браузере клиента                                              |
| Устанавливаются | Сервером (через HTTP-заголовок) или клиентом (через JavaScript) |
| Видимость       | Не отображаются в адресной строке                               |
| Назначение      | Идентификация, аутентификация, хранение состояния               |
| Автоматизация   | Автоматически добавляются к запросам                            |
| Безопасность    | Могут быть защищены флагами `Secure`, `HttpOnly`, `SameSite`    |

## 2. Основы работы с Cookie в JavaScript

### Что такое Cookie в JavaScript?

Прежде чем перейти к практике использования Cookie, необходимо понять их природу и ключевые отличия от других сущностей JavaScript.

**Cookie (куки) — это небольшие фрагменты данных, которые браузер сохраняет от имени веб-сайта**. Главное отличие от других объектов JavaScript — **cookie передаются между клиентом и сервером в составе HTTP-запросов**. Это означает, что они **существуют как текстовая строка и передаются в HTTP-заголовках, а не как полноценные структуры вроде объектов или массивов**.

Следовательно, **создание, изменение и удаление cookie в JavaScript осуществляется строковыми операциями**.

### Структура и идентификация Cookie

Один домен может использовать множество cookie, например, для хранения:

- информации об авторизации;
- предпочтений пользователя;
- параметров сессии и т. д.

Чтобы отличать cookie между собой, каждому присваивается уникальное имя. По синтаксису они схожи с переменными:

```js
имя = значение;
```

> Если cookie с таким именем уже существует, новая строка перезапишет значение. Это позволяет удобно обновлять данные пользователя.

### Время жизни `Cookie` (expires)

В отличие от переменных JavaScript, **cookie могут иметь ограниченное время жизни**, после которого они автоматически удаляются.

Примеры применения:

- **В системах авторизации** (сессии с ограниченным временем).
- **В интернет-банкинге** (короткий срок жизни — в целях безопасности).
- **В форумах или почтовых сервисах** (длительный срок — ради удобства пользователя).

> Атрибут `expires` позволяет указать **срок действия `cookie`**. После этой даты браузер автоматически удалит `cookie` и больше не будет его передавать серверу.

### Поддомены и область действия (path, domain)

На больших сайтах часто используется иерархия поддоменов. Например:

- `reg.mystep.org` — регистрация и восстановление доступа
- `service.mystep.org` — список сервисов

Возникает задача: ограничить или расширить доступ к cookie между поддоменами.

Основные параметры:

- `path=/` — cookie доступно на всех страницах сайта.
- `domain=mystep.org` — cookie будет доступно всем поддоменам сайта.

> 👉 Если параметр domain не указан, cookie работает только на текущем домене.

### 🧠 Где хранятся Cookie в JavaScript?

Вся информация о cookie доступна через свойство:

```js
document.cookie;
```

> ⚠️ Важно: это строка, а не объект. Хотя cookie могут быть множественными, их значения сериализуются и хранятся в одной строке вида:

```arduino
"key1=value1; key2=value2; key3=value3"
```

#### 📌 Особенности:

- `document.cookie` включает все `cookie`, переданные с сервера при загрузке страницы.
- Это свойство доступно для **чтения и записи на клиенте**.
- `Cookie`, добавленные через JavaScript, будут передаваться на сервер до истечения срока действия.

### Создание `Cookie` в JavaScript

Для добавления `cookie` необходимо **присвоить новое значение строке document.cookie**.

⚠️ Особенность:

- В отличие от сложения строк через +=, **cookie устанавливаются простым присваиванием =. При этом существующие cookie не затираются**:

```js
document.cookie =
  "registered=User; expires=Thu, 14 Feb 2019 08:12:40 GMT; path=/";
```

🔍 Разбор строки:

- `registered=User` — имя и значение `cookie`.
- `expires=Thu, 14 Feb 2019 08:12:40 GMT` — срок действия в формате RFC 2822.
- `path=/` — область действия (все страницы сайта).

> ❗ Все ключевые слова (`expires`, `path`, `domain`, `secure`) должны быть написаны точно. Иные варианты (например, «expiry» или другие форматы даты) не поддерживаются.

### Формат даты и валидность

Формат даты должен строго соответствовать стандарту RFC 2822:

```text
Thu, 14 Feb 2019 08:12:40 GMT
```

Примеры некорректных форматов:

- `2019-02-14 08:12:40`
- `02/14/2019 08:12:40`

Эти записи могут быть допустимы в других API, но не будут работать в `cookie`.

### Дополнительные атрибуты Cookie

#### 1. domain=mystep.org

- Позволяет задать, на каком домене или поддоменах будет действовать cookie.

#### 2. secure

- Указывает, что cookie может передаваться только по HTTPS.
- ❗ Используется без значения:

  ```js
  secure;
  ```

- Если сайт работает через `HTTP` (не HTTPS), такая `cookie` не будет отправлена.

### Пример установки cookie с максимальной детализацией:

```js
document.cookie =
  "registered=User; expires=Thu, 14 Feb 2019 08:12:40 GMT; path=/; domain=mystep.org; secure";
```

#### 📋 Это cookie:

- Названа registered
- Содержит значение User
- Действует до 14 февраля 2019 года
- Доступна на всех страницах сайта
- Доступна на поддоменах \*.mystep.org
- Передаётся только по защищенному соединению

## 3. Чтение и отображение Cookie

Когда нам нужно получить текущие cookie, установленные для страницы, мы используем встроенное свойство JavaScript — document.cookie. Это свойство возвращает строку, содержащую все активные cookie, доступные текущему документу. Формат этой строки следующий:

```js
имя1=значение1; имя2=значение2; ...
```

Каждая пара **отделена точкой с запятой и пробелом** (`; `). Однако важно помнить: в этой строке **отсутствуют данные о сроке действия** (`expires`), **пути** (`path`), **домене** (`domain`) и других параметрах. **Эти сведения доступны только на этапе установки cookie**.

### Ограничения: домены и локальные файлы

Cookie устанавливаются только для домена, на котором выполняется страница. Это значит, что если вы открываете HTML-файл напрямую с компьютера (через file://), установка cookie, скорее всего, не сработает.

> Важно: **Cookie не работают с локальными файлами. Чтобы протестировать работу с cookie, необходимо использовать**:

- настоящий домен (локальный сервер типа `localhost`). Можно запустить с помощью плагина `Live Server` для VSCode.
- или онлайн-редактор, работающий через домен.

### Упражнение: Установка и отображение Cookie

Скопируйте следующий HTML-код в редактор и замените дату `expires` на актуальную (например, на год вперёд от сегодняшнего дня).

```html
<!DOCTYPE html>
<html>
  <body>
    <p id="out"></p>
    <script>
      document.cookie =
        "registered=User; expires=Fri, 31 May 2026 08:12:40 GMT; path=/";
      document.cookie =
        "organization=Step; expires=Fri, 31 May 2026 08:12:40 GMT; path=/";

      window.out.innerHTML = document.cookie;
    </script>
  </body>
</html>
```

#### Пояснение:

- Элемент `<p id="out"></p>` — это пустой абзац, в который будет выведена информация с помощью JavaScript.
- В скрипте устанавливаются два cookie:
  - registered=User
  - organization=Step
- Устанавливается:
  - одинаковый срок действия (expires)
  - область действия (path=/) — означает доступность cookie для всех страниц на текущем сайте.
- Затем значение document.cookie выводится в абзац с id="out".

На странице появится результат — **строка с cookie**, которая может выглядеть примерно так:

```ini
registered=User; organization=Step
```

Если в редакторе уже были установлены другие `cookie`, они также могут появиться в этой строке — например, **cookie самого редактора, установленные сервером**.

### Преобразование строки cookie в объект

**Работать со строкой, содержащей все cookie, не всегда удобно**. Чтобы упростить доступ к значениям `cookie` по имени, мы можем **преобразовать строку `document.cookie` в объект**, где каждому имени `cookie` будет соответствовать его значение.

#### Шаги преобразования:

```javascript
var x = document.cookie; // Получаем строку всех cookie
var s = x.split("; "); // Разбиваем строку на пары 'имя=значение'
var cookieObject = {}; // Создаём пустой объект
var c;

for (var i = 0; i < s.length; i++) {
  c = s[i].split("="); // Разбиваем каждую пару на имя и значение
  cookieObject[c[0]] = c[1]; // Добавляем в объект как ключ и значение
}
```

Объяснение:

- `split('; ')` — создаёт массив строк, каждая из которых — это отдельный cookie.
- Внутренний `split('=')` — делит каждую пару на ключ и значение.
- `cookieObject[c[0]] = c[1]` — сохраняет результат в объект, делая доступ к cookie более удобным.

Теперь cookieObject может выглядеть, например, так:

```javascript
{
  registered: "User",
  organization: "Step"
}
```

### Вывод cookie по строкам

Для наглядного вывода каждой пары cookie (ключ и значение) в отдельной строке используем цикл for-in:

```javascript
for (var co in cookieObject) {
  window.out.innerHTML += co + " = " + cookieObject[co] + "<br/>";
}
```

Здесь:

- `co` — имя (ключ) cookie
- `cookieObject[co]` — его значение
- `"<br/>"` — HTML-тег для переноса строки

### Итоговый код

```html
<!DOCTYPE html>
<html>
  <body>
    <p id="out"></p>
    <script>
      document.cookie =
        "registered=User; expires=Fri, 31 May 2026 08:12:40 GMT; path=/";
      document.cookie =
        "organization=Step; expires=Fri, 31 May 2026 08:12:40 GMT; path=/";

      var x = document.cookie;
      var s = x.split("; ");
      var cookieObject = {};
      var c;

      for (var i = 0; i < s.length; i++) {
        c = s[i].split("=");
        cookieObject[c[0]] = c[1];
      }

      for (var co in cookieObject) {
        window.out.innerHTML += co + " = " + cookieObject[co] + "<br/>";
      }
    </script>
  </body>
</html>
```

После запуска вы увидите каждую cookie на новой строке, например:

```ini
registered = User
organization = Step
```

> **Обратите внимание**: порядок вывода может отличаться. Это нормально — браузер не гарантирует порядок следования `cookie`.

## 4. Простая система имитации авторизации на основе Cookie

Теперь давайте создадим простейшую **систему, имитирующую авторизацию пользователей**. Для этого мы:

- **Перехватим событие загрузки страницы `onload` и назначим для него обработчик**, чтобы при открытии страницы можно было различать зарегистрированного и незарегистрированного пользователя;
- **Внутри обработчика проверим, установлено ли `cookie` с именем `register`**;
- **Если `cookie` есть — поприветствуем пользователя** (его имя хранится как значение cookie);
- **Если `cookie` нет — предложим пользователю пройти регистрацию** (ввести имя и нажать кнопку).

### HTML-разметка и подключение JavaScript

Ниже приведён HTML-документ со встроенным JavaScript-кодом.

```html
<!DOCTYPE html>
<html>
  <body onload="checkReg()">
    <div id="regDiv"></div>

    <script>
      function checkReg() {
        var x = document.cookie; // получаем строку всех cookie
        var rd = document.getElementById("regDiv"); // получаем блок для вывода
        var s = x.split("; "); // разбиваем cookie по отдельным парам ключ=значение
        var cookieObject = {}; // создаем объект для хранения cookies
        var c;

        // парсим каждую пару и записываем в объект
        for (var i = 0; i < s.length; i++) {
          c = s[i].split("=");
          cookieObject[c[0]] = c[1];
        }

        if ("register" in cookieObject) {
          // если cookie 'register' существует
          rd.innerHTML = "Hello, " + cookieObject["register"];
        } else {
          // если cookie нет — предлагаем зарегистрироваться
          rd.innerHTML = `
            Name: <input type="text" id="name" />
            <input type="button" value="Register" onclick="regClick()" />
          `;
        }
      }

      function regClick() {
        var inputName = document.getElementById("name");
        var name = inputName.value;

        var expDate = new Date();
        expDate.setTime(new Date().getTime() + 60 * 1000); // устанавливаем срок действия cookie — 1 минута

        document.cookie =
          "register=" + name + ";expires=" + expDate.toGMTString() + ";path=/"; // устанавливаем cookie

        checkReg(); // вызываем проверку снова, чтобы отобразить приветствие
      }
    </script>
  </body>
</html>
```

### Подробный разбор

#### 1. Подключение обработчика загрузки

```html
<body onload="checkReg()"></body>
```

Событие onload сработает, когда документ полностью загрузится. Мы сразу вызываем функцию `checkReg()`, которая отвечает за проверку авторизации и обновление интерфейса.

#### 2. Блок для отображения информации

```html
<div id="regDiv"></div>
```

В этот блок мы будем динамически вставлять либо приветствие, либо форму регистрации в зависимости от того, зарегистрирован пользователь или нет. Используется вместо ранее применявшегося `<p id="out">`.

#### 3. Функция `checkReg`

Эта функция:

- Получает строку всех cookies: `document.cookie`;
- Разбивает её на массив `["ключ=значение", ...]`;
- `Парсит массив в объект cookieObject вида { ключ: значение, ... }`;
- Проверяет наличие ключа `'register'`;
- **Если он есть — выводит приветствие**;
- **Если нет — отображает HTML-разметку формы с кнопкой**.
- Пояснение по парсингу `cookies`:

```js
var s = x.split("; ");
for (var i = 0; i < s.length; i++) {
  c = s[i].split("=");
  cookieObject[c[0]] = c[1];
}
```

**Cookie — это строка вида `"register=Иван; theme=dark"`. Мы разбиваем строку по `; `, затем каждую подстроку делим по `=` и добавляем в объект `cookieObject`**.

#### 4. Отображение формы регистрации

Если ключ 'register' не найден, в блок regDiv вставляется HTML-код:

```html
Name: <input type="text" id="name" />
<input type="button" value="Register" onclick="regClick()" />
```

Пользователь может ввести имя и нажать кнопку — будет вызвана функция `regClick()`.

#### 5. Функция `regClick`

```js
function regClick() {
  var inputName = document.getElementById("name");
  var name = inputName.value;

  var expDate = new Date();
  expDate.setTime(new Date().getTime() + 60 * 1000); // 1 минута

  document.cookie =
    "register=" + name + ";expires=" + expDate.toGMTString() + ";path=/";

  checkReg(); // повторный вызов для обновления интерфейса
}
```

Что здесь происходит:

- Получаем имя пользователя из поля ввода.
- Создаем объект Date и устанавливаем время на 1 минуту вперёд.
- Формируем строку `cookie`:
  - `имя: register`,
  - `значение: введённое имя`,
  - `срок действия: через 1 минуту`,
  - `путь: / — доступно для всей страницы`.
- Устанавливаем `cookie`, после чего повторно вызываем `checkReg()` — интерфейс обновляется, и пользователь получает приветствие.

> 💡 Альтернатива: вместо `checkReg()` можно вызвать `location.reload()` для перезагрузки страницы. Это предпочтительнее на реальных сайтах, но может не работать в учебных редакторах.

### Тестирование

- **Запустите страницу: отобразится форма регистрации**.
- **Введите имя и нажмите `«Register»` — появится приветствие**.
- **Повторный запуск (`Run`) отобразит то же приветствие — `cookie` всё ещё действует**.
- **Подождите 1 минуту, снова запустите скрипт — появится форма, т.к. `cookie` устарело и удалилось**.

### Как удалить `Cookie` вручную?

Удаление cookie — это не отдельная команда, а установка cookie с прошедшим сроком действия:

```js
var expDate = new Date();
expDate.setTime(new Date().getTime() - 60 * 1000); // прошлая дата
document.cookie = "register=;expires=" + expDate.toGMTString() + ";path=/";
```

> Такой приём приведёт к удалению `cookie`. Этим же способом можно программно реализовать «выход» пользователя из системы.

### Выводы

- Мы научились проверять наличие `cookie` и адаптировать содержимое страницы.
- Научились создавать и устанавливать `cookie` с ограниченным сроком действия.
- Поняли, как использовать `cookie` для простой имитации авторизации.

## 5. Преимущества и недостатки `cookie`

### Идентификация пользователей через cookie

**Как уже упоминалось ранее, `cookie` используются для различения клиентов, то есть хранения информации, индивидуальной для каждого пользователя**. Это может быть как логин, так и история действий на сайте, настройки интерфейса или содержимое корзины покупок. `Cookie` играют роль своеобразного удостоверения личности в цифровом пространстве.

### 📚 Аналогия:

Использование cookie можно сравнить с предъявлением читательского билета в библиотеке или удостоверения личности в банке. Без этих документов вас, скорее всего, не обслужат, или окажут услуги в урезанном объеме. Но если документ потерян или украден, им может воспользоваться злоумышленник — это уже несет потенциальную угрозу.

Точно так же и в случае с cookie:

- **Плюс** — вы узнаваемы, и сайт может предоставлять вам удобные и персонализированные сервисы.
- **Минус** — эта информация может быть перехвачена или использована без вашего ведома.

### Авторизация и поддержка сессии

Одной из важнейших сфер применения cookie является авторизация. Алгоритм работы простой:

- Пользователь вводит логин и пароль.
- Сервер проверяет достоверность введённых данных.
- При успешной проверке сервер устанавливает cookie с токеном авторизации.
- При последующих обращениях браузер автоматически отправляет этот cookie, позволяя серверу «узнать» пользователя.

🔐 Это означает, что при следующих визитах повторный ввод логина и пароля не требуется — пока cookie действителен, вы считаетесь авторизованным.

💡 Это удобно, особенно на сайтах, которые вы посещаете часто. Но...

> ⚠️ Главное правило информационной безопасности:
> Чем удобнее, тем потенциально опаснее.

Если авторизационные cookie сохраняются надолго:

- Другой человек, севший за ваш компьютер, может получить доступ к вашим данным.
- `Cookie` можно найти в файловой системе и использовать их для авторизации на стороннем устройстве.
- Использование чужого компьютера или смартфона без очистки `cookie` может привести к несанкционированному доступу.

> 📌 Рекомендация:
> Никогда не включайте сохранение авторизационных данных на чужих или общедоступных устройствах. Используйте режим «инкогнито» или выходите из аккаунтов перед закрытием браузера.

### Персонализированная реклама и слежка

Еще одно распространенное применение `cookie` — это персонализация рекламы. Сайты запоминают:

- Просмотренные страницы.
- Избранные товары.
- Время активности.
- Геолокацию (косвенно).

Эта информация позволяет показывать релевантную рекламу — ту, которая вас действительно может заинтересовать.

#### 📈 Плюсы:

- Реклама становится целевой (таргетированной), а значит, менее раздражающей.
- Повышается эффективность маркетинга — пользователю не показывают бесполезные объявления.

#### 🔍 Минусы:

- Сайт может отслеживать ваше поведение: сколько вы были онлайн, какие страницы посещали, в какое время.
- Нежелательная навязчивость — например, реклама товара, который вы уже купили.
- Нарушение конфиденциальности — особенно если данные анализируются сторонними рекламными сетями.

### Ограничения и объем хранения

Cookie сохраняются в виде файлов на жестком диске, чтобы данные были доступны даже после перезапуска браузера.

Но для безопасности и оптимизации работы браузеры вводят ограничения:

- Общее количество `cookie` — до 300 записей.
- Размер одного `cookie` — не более 4 Кб.
- Для одного домена — до 20 `cookie`.

#### 📏 Таким образом, общий максимальный объем cookie:

- 300 cookie × 4 Кб = 1200 Кб (~1,2 МБ)

> 📌 Для современных устройств (в том числе смартфонов) это незначительный объем, особенно если учесть, насколько полезно хранение данных для восстановления состояния сессии.

### Хранение и управление cookie

Ранее файлы `cookie` сохранялись в папке самого браузера. Современные операционные системы и браузеры учитывают многопользовательскую работу:

- `Cookie` хранятся в персональных папках профиля пользователя.
- Есть встроенные инструменты для управления `cookie` — как глобально, так и для конкретных сайтов.

#### Например:

- Удаление `cookie`.
- Блокировка сторонних `cookie`.
- Настройка автозапросов и разрешений.

#### 🔧 Также `cookie` можно контролировать с помощью:

- Антивирусов и средств защиты.
- Расширений браузера (например, `Cookie AutoDelete`, `Ghostery`).

### Безопасность и юридическое регулирование

Cookie — инструмент, который может использоваться как на благо, так и во вред.
Полное отключение cookie сделает работу с сайтами менее удобной:

- Повторная авторизация на каждом шаге.
- Потеря пользовательских настроек.
- Ошибки в работе некоторых сервисов.

Однако неосторожное обращение с cookie, особенно на чужих устройствах, может привести к утечке персональных данных.

> 📌 Совет:
> Не отказывайтесь от использования cookie, но очищайте их после работы на чужом компьютере и проверяйте разрешения для сайтов.

### Вывод

Cookie — это мощный инструмент, который делает взаимодействие с веб-приложениями более удобным, быстрым и персонализированным. Однако вместе с преимуществами появляются риски:

| ✅ Преимущества                     | ⚠️ Недостатки                            |
| ----------------------------------- | ---------------------------------------- |
| Быстрая авторизация                 | Возможность несанкционированного доступа |
| Персонализация интерфейса и рекламы | Нарушение конфиденциальности             |
| Хранение состояния между сессиями   | Ограничение по объему и количеству       |
| Упрощение взаимодействия с сайтом   | Потенциальная навязчивость рекламы       |

Чтобы эффективно использовать cookie и минимизировать риски, соблюдайте простые правила:

- Не сохраняйте авторизационные cookie на чужих устройствах.
- Регулярно очищайте cookie и кеш.
- Настраивайте разрешения в браузере.
- Используйте антивирусы и защитные расширения.
- Уважайте уведомления сайтов — они служат в том числе для вашей безопасности.
